<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>todox</title>
  <link rel="stylesheet" href="{{.StylesPath}}">
</head>
<body>
  <h2>todox</h2>
  <div id="error-banner" class="error-banner" role="alert" aria-live="assertive">
    <span id="error-message"></span>
    <button type="button" id="error-close" aria-label="Close">&times;</button>
  </div>
  <form id="f">
    <label>type:
      <select name="type">
        <option>both</option>
        <option>todo</option>
        <option>fixme</option>
      </select>
    </label>
    <label>mode:
      <select name="mode">
        <option>last</option>
        <option>first</option>
      </select>
    </label>
    <label>author (regexp): <input name="author" type="text"></label>
    <label>path (CSV ok): <input name="path" type="text" placeholder="src,pkg"></label>
    <label>exclude (CSV ok): <input name="exclude" type="text" placeholder="vendor/**"></label>
    <label>path regex: <input name="path_regex" type="text" placeholder="\\.go$"></label>
    <label><input type="checkbox" name="with_comment"> comment</label>
    <label><input type="checkbox" name="with_message"> message</label>
    <label><input type="checkbox" name="with_commit_link"> commit link</label>
    <label><input type="checkbox" name="with_pr_links"> PR links</label>
    <label>PR state:
      <select name="pr_state">
        <option value="all">all</option>
        <option value="open">open</option>
        <option value="merged">merged</option>
        <option value="closed">closed</option>
      </select>
    </label>
    <label>PR prefer:
      <select name="pr_prefer">
        <option value="open">open</option>
        <option value="merged">merged</option>
        <option value="closed">closed</option>
        <option value="none">none</option>
      </select>
    </label>
    <label>PR limit: <input type="number" name="pr_limit" min="1" max="20" value="3" inputmode="numeric" pattern="[0-9]*"></label>
    <label><input type="checkbox" name="ignore_ws" checked> ignore whitespace</label>
    <label><input type="checkbox" name="exclude_typical"> exclude typical dirs</label>
    <label>jobs: <input type="number" name="jobs" min="1" max="64" inputmode="numeric" pattern="[0-9]*" placeholder="auto"></label>
    <label>truncate: <input type="text" name="truncate" value="120"></label>
    <button type="submit">Scan</button>
  </form>
  <p class="small">Tip: Same params as CLI. Example: <code>/api/scan?type=todo&amp;mode=first&amp;with_comment=1</code></p>
  <div id="progress" class="progress-wrap" aria-live="polite" hidden>
    <div class="progress-header">
      <strong id="progress-stage">scan</strong>
      <span id="progress-stats" class="muted"></span>
      <button type="button" id="progress-cancel" class="linklike">キャンセル</button>
    </div>

    <ol class="stepper" aria-label="Stages">
      <li id="st-scan" class="current">scan</li>
      <li id="st-attr">attr</li>
      <li id="st-pr">pr</li>
    </ol>

    <div id="progressbar" class="progressbar" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0" aria-label="Stage progress">
      <div id="progressbar-inner" style="width:0%"></div>
    </div>

    <div class="progress-footer muted">
      <span id="progress-eta">ETA: —</span>
      <span id="progress-rate">Rate: —</span>
      <span id="progress-elapsed">Elapsed: —</span>
    </div>
  </div>
  <div id="out"></div>
  <script>
  const f=document.getElementById('f');
  const out=document.getElementById('out');
  const banner=document.getElementById('error-banner');
  const bannerMsg=document.getElementById('error-message');
  const bannerClose=document.getElementById('error-close');
  const prog=document.getElementById('progress');
  const progInner=document.getElementById('progressbar-inner');
  const progBar=document.getElementById('progressbar');
  const progStage=document.getElementById('progress-stage');
  const progStats=document.getElementById('progress-stats');
  const progETA=document.getElementById('progress-eta');
  const progRate=document.getElementById('progress-rate');
  const progElapsed=document.getElementById('progress-elapsed');
  const btnCancel=document.getElementById('progress-cancel');
  const stScan=document.getElementById('st-scan');
  const stAttr=document.getElementById('st-attr');
  const stPr=document.getElementById('st-pr');

  let es=null;
  let lastSnap=null;
  let rafId=0;
  let fetchAbort=null; // AbortController | null

  function showError(msg){
    bannerMsg.textContent=msg;
    banner.style.display='flex';
  }

  function hideError(){
    banner.style.display='none';
    bannerMsg.textContent='';
  }

  function escText(value){
    return String(value||'')
      .replace(/&/g,'&amp;')
      .replace(/</g,'&lt;')
      .replace(/>/g,'&gt;');
  }

  function escAttr(value){
    return String(value||'')
      .replace(/&/g,'&amp;')
      .replace(/</g,'&lt;')
      .replace(/>/g,'&gt;')
      .replace(/"/g,'&quot;')
      .replace(/'/g,'&#39;');
  }

  function renderBadge(kind){
    const raw=String(kind||'');
    if(!raw){
      return '';
    }
    const upper=raw.toUpperCase();
    let dataType='OTHER';
    if(upper==='TODO' || upper==='FIXME'){
      dataType=upper;
    }
    return '<span class="badge" data-type="'+dataType+'">'+escText(upper)+'</span>';
  }

  function renderResultTable(data){
    if(!data || typeof data!=='object'){
      return '<p>No results.</p>';
    }
    const rows=Array.isArray(data.items)?data.items:[];
    const errs=Array.isArray(data.errors)?data.errors:[];
    const parts=[];
    if(errs.length>0){
      let list='<ul>';
      for(const e of errs){
        const fileRaw=e&&e.file?e.file:'(unknown)';
        const lineRaw=e&&typeof e.line==='number'&&e.line>0?String(e.line):'—';
        const loc=fileRaw+':'+lineRaw;
        const stage=e&&e.stage?e.stage:'git';
        list+='<li><code>'+escText(loc)+'</code> ['+escText(stage)+'] '+escText(e&&e.message?e.message:'')+'</li>';
      }
      list+='</ul>';
      parts.push('<div class="errors"><strong>'+errs.length+' error(s)</strong>'+list+'</div>');
    }
    if(!rows || rows.length===0){
      parts.push('<p>No results.</p>');
      return parts.join('');
    }
    const hasAge=!!data.has_age;
    const hasComment=!!data.has_comment;
    const hasMessage=!!data.has_message;
    const hasURL=!!data.has_url;
    const hasPRS=!!data.has_prs;
    const headerCells=['TYPE','AUTHOR','EMAIL','DATE'];
    if(hasAge){headerCells.push('AGE');}
    headerCells.push('COMMIT','LOCATION');
    if(hasURL){headerCells.push('URL');}
    if(hasPRS){headerCells.push('PRS');}
    if(hasComment){headerCells.push('COMMENT');}
    if(hasMessage){headerCells.push('MESSAGE');}
    let h='<table><thead><tr>'+headerCells.map(hd=>'<th>'+hd+'</th>').join('')+'</tr></thead><tbody>';
    for(const r of rows){
      const cells=[];
      cells.push('<td>'+renderBadge(r&&r.kind)+'</td>');
      cells.push('<td>'+escText(r&&r.author)+'</td>');
      cells.push('<td>'+escText(r&&r.email)+'</td>');
      cells.push('<td>'+escText(r&&r.date)+'</td>');
      if(hasAge){
        const ageRaw=r&&r.age_days!=null?String(r.age_days):'';
        cells.push('<td>'+escText(ageRaw)+'</td>');
      }
      const commitRaw=r&&r.commit?String(r.commit).slice(0,8):'';
      cells.push('<td><code>'+escText(commitRaw)+'</code></td>');
      const fileRaw=r&&r.file?String(r.file):'';
      const lineRaw=r&&typeof r.line==='number'&&r.line>0?String(r.line):'';
      cells.push('<td><code>'+escText(fileRaw+':'+lineRaw)+'</code></td>');
      if(hasURL){
        const urlRaw=r&&r.url?String(r.url):'';
        if(urlRaw){
          const href=escAttr(urlRaw);
          cells.push('<td><a class="link-icon" href="'+href+'" target="_blank" rel="noopener noreferrer" aria-label="GitHub で開く"><span aria-hidden="true">🔗</span></a></td>');
        }else{
          cells.push('<td></td>');
        }
      }
      if(hasPRS){
        const list=Array.isArray(r&&r.prs)?r.prs:[];
        if(list.length){
          const entries=[];
          for(const pr of list){
            const num=pr&&typeof pr.number==='number'&&isFinite(pr.number)&&pr.number>0?pr.number:null;
            const rawState=pr&&pr.state!=null?String(pr.state).trim():'';
            const stateLower=rawState.toLowerCase();
            const displayState=stateLower||'unknown';
            const stateSuffix='('+escText(displayState)+')';
            if(num!==null && pr && pr.url){
              const href=escAttr(String(pr.url));
              const ariaState=displayState?displayState.charAt(0).toUpperCase()+displayState.slice(1)+' ':'';
              const aria=ariaState+'PR #'+num;
              entries.push('<a href="'+href+'" target="_blank" rel="noopener noreferrer" aria-label="'+escAttr(aria)+'">#'+num+'</a>'+stateSuffix);
            }else if(num!==null){
              entries.push('#'+num+stateSuffix);
            }else if(pr && pr.url){
              const href=escAttr(String(pr.url));
              const aria=displayState?displayState.charAt(0).toUpperCase()+displayState.slice(1)+' pull request':'Pull request';
              entries.push('<a href="'+href+'" target="_blank" rel="noopener noreferrer" aria-label="'+escAttr(aria)+'">'+stateSuffix+'</a>');
            }else{
              entries.push(stateSuffix);
            }
          }
          cells.push('<td>'+entries.join('; ')+'</td>');
        }else{
          cells.push('<td></td>');
        }
      }
      if(hasComment){
        cells.push('<td>'+escText(r&&r.comment)+'</td>');
      }
      if(hasMessage){
        cells.push('<td>'+escText(r&&r.message)+'</td>');
      }
      h+='<tr>'+cells.join('')+'</tr>';
    }
    h+='</tbody></table>';
    parts.push(h);
    return parts.join('');
  }

  function resetProgressUI(){
    progStage.textContent='scan';
    progStats.textContent='0/— done';
    progETA.textContent='ETA: —';
    progRate.textContent='Rate: —';
    progElapsed.textContent='Elapsed: —';
    updateProgressBar(0,false);
    setStepper('scan');
  }

  function showProgressUI(){
    prog.hidden=false;
    resetProgressUI();
    prog.setAttribute('aria-busy','true');
  }

  function hideProgressUI(){
    prog.hidden=true;
    prog.removeAttribute('aria-busy');
    lastSnap=null;
    if(rafId && typeof cancelAnimationFrame==='function'){
      cancelAnimationFrame(rafId);
      rafId=0;
    }
    btnCancel.onclick=null;
  }

  function setStepper(stage){
    const stages={scan:stScan,attr:stAttr,pr:stPr};
    for(const key of Object.keys(stages)){
      const el=stages[key];
      if(!el){continue;}
      el.classList.remove('current');
      el.classList.remove('done');
    }
    if(stage==='scan'){
      stScan.classList.add('current');
    }else if(stage==='attr'){
      stScan.classList.add('done');
      stAttr.classList.add('current');
    }else if(stage==='pr'){
      stScan.classList.add('done');
      stAttr.classList.add('done');
      stPr.classList.add('current');
    }
  }

  function togglePRStepVisibility(enabled){
    if(!stPr){return;}
    stPr.style.display = enabled ? '' : 'none';
  }

  function updateProgressBar(percent,determinate){
    const pct=Math.max(0,Math.min(100,percent||0));
    progInner.style.width=pct+'%';
    if(progBar){
      if(determinate){
        progBar.setAttribute('aria-valuenow',String(Math.round(pct)));
        progBar.removeAttribute('aria-valuetext');
      }else{
        progBar.removeAttribute('aria-valuenow');
        progBar.setAttribute('aria-valuetext','in progress');
      }
    }
  }

  function renderProgressOnce(){
    rafId=0;
    if(!lastSnap){
      return;
    }
    const s=lastSnap;
    const nf = (typeof Intl!=='undefined'&&Intl.NumberFormat)?new Intl.NumberFormat():{format:(v)=>String(v)};
    progStage.textContent=s.stage||'';
    setStepper(s.stage);
    const determinate=!!(s.total&&s.total>0);
    let percent=0;
    if(determinate){
      percent=(s.done/s.total)*100;
    }
    updateProgressBar(percent,determinate);
    const totalLabel=determinate?nf.format(s.total):'—';
    const statText=nf.format(s.done||0)+'/'+totalLabel+' done';
    const rateLabel=typeof s.rate_per_sec==='number'&&isFinite(s.rate_per_sec)?nf.format(Number(s.rate_per_sec.toFixed(1)))+'/sec':'—';
    function fmtEta(sec){
      if(!(typeof sec==='number'&&isFinite(sec))){return '—';}
      const mm=Math.floor(sec/60);
      const ss=Math.round(sec%60);
      return nf.format(Number(sec.toFixed(1)))+'s ('+mm+':'+String(ss).padStart(2,'0')+')';
    }
    const etaLabel=fmtEta(s.eta_sec_p50);
    const elapsedLabel=typeof s.elapsed_sec==='number'&&isFinite(s.elapsed_sec)?s.elapsed_sec.toFixed(1)+'s':'—';
    progStats.textContent=statText;
    progRate.textContent='Rate: '+rateLabel;
    progETA.textContent='ETA: '+etaLabel;
    progElapsed.textContent='Elapsed: '+elapsedLabel;
  }

  function scheduleRender(){
    if(typeof requestAnimationFrame!=='function'){
      renderProgressOnce();
      return;
    }
    if(rafId){
      return;
    }
    rafId=requestAnimationFrame(renderProgressOnce);
  }

  function closeStream(){
    if(es){
      try{es.close();}catch(_){ }
      es=null;
    }
  }

  async function startScanWithFetch(q){
    hideProgressUI();
    out.innerHTML='';
    // フォールバック実行中のキャンセル対応
    fetchAbort = new AbortController();
    const { signal } = fetchAbort;
    try{
      const res=await fetch('/api/scan?'+q.toString(), { signal });
      const raw=await res.text();
      if(!res.ok){
        let msg='HTTP '+res.status;
        if(res.statusText){
          msg+=' '+res.statusText;
        }
        const trimmed=raw.trim();
        if(trimmed){
          msg+=': '+trimmed;
        }
        throw new Error(msg);
      }
      let data=null;
      const trimmed=raw.trim();
      if(trimmed!==''){
        try{
          data=JSON.parse(trimmed);
        }catch(parseErr){
          const detail=parseErr instanceof Error?parseErr.message:String(parseErr);
          throw new Error('Failed to parse response JSON: '+detail);
        }
      }
      out.innerHTML=renderResultTable(data);
    }catch(err){
      if(err && err.name === 'AbortError'){
        // キャンセル時は静かに終了
        return;
      }
      console.error(err);
      showError(err instanceof Error?err.message:String(err));
    } finally {
      fetchAbort = null;
    }
  }

  function startScanWithSSE(q){
    closeStream();
    out.innerHTML='';
    showProgressUI();
    try{
      es=new EventSource('/api/scan/stream?'+q.toString());
    }catch(err){
      hideProgressUI();
      showError(err instanceof Error?err.message:String(err));
      return;
    }

    es.addEventListener('progress',(ev)=>{
      try{
        lastSnap=JSON.parse(ev.data);
        scheduleRender();
      }catch(parseErr){
        console.warn('progress parse failed',parseErr);
      }
    });

    es.addEventListener('result',(ev)=>{
      try{
        const res=JSON.parse(ev.data);
        hideProgressUI();
        out.innerHTML=renderResultTable(res);
      }catch(parseErr){
        console.error(parseErr);
        showError(parseErr instanceof Error?parseErr.message:String(parseErr));
      }finally{
        closeStream();
      }
    });

    function handleServerError(ev){
      if(!ev || typeof ev.data==='undefined'){
        return;
      }
      try{
        const payload=JSON.parse(ev.data||'{}');
        showError(payload&&payload.message?payload.message:'stream error');
      }catch(parseErr){
        showError(parseErr instanceof Error?parseErr.message:String(parseErr));
      }
      hideProgressUI();
      closeStream();
    }
    es.addEventListener('error', handleServerError);
    es.addEventListener('server_error', handleServerError);

    es.onerror=(ev)=>{
      if(ev && typeof ev.data!=='undefined'){
        return;
      }
      if(!es){
        return;
      }
      const label=(lastSnap&&es.readyState===EventSource.CONNECTING)?'reconnecting…':'connecting…';
      progStats.textContent=label;
    };

    btnCancel.onclick=()=>{
      closeStream();
      if(fetchAbort){
        try{ fetchAbort.abort(); }catch(_){ }
        fetchAbort=null;
      }
      hideProgressUI();
    };
  }

  function buildQueryParams(){
    const fd=new FormData(f);
    const q=new URLSearchParams(fd);
    const ignoreEl=f.elements.namedItem('ignore_ws');
    if(ignoreEl instanceof HTMLInputElement){
      if(ignoreEl.checked){
        q.delete('ignore_ws');
      }else{
        q.set('ignore_ws','0');
      }
    }
    for(const key of ['path','exclude','path_regex']){
      const values=q.getAll(key);
      q.delete(key);
      const cleaned=[];
      for(const value of values){
        if(value==null){
          continue;
        }
        for(const piece of String(value).split(',')){
          const trimmed=piece.trim();
          if(trimmed){
            cleaned.push(trimmed);
          }
        }
      }
      for(const entry of cleaned){
        q.append(key,entry);
      }
    }
    const excludeTypical=f.elements.namedItem('exclude_typical');
    if(excludeTypical instanceof HTMLInputElement){
      if(excludeTypical.checked){
        q.set('exclude_typical','1');
      }else{
        q.delete('exclude_typical');
      }
    }
    const jobsEl=f.elements.namedItem('jobs');
    if(jobsEl instanceof HTMLInputElement){
      if((jobsEl.value||'').trim()===''){
        q.delete('jobs');
      }
    }
    return q;
  }

  bannerClose.addEventListener('click',(e)=>{
    e.preventDefault();
    hideError();
  });

  // PR ステップの動的表示（初期化）
  (function(){
    const prCheck=f.elements.namedItem('with_pr_links');
    if(prCheck instanceof HTMLInputElement){
      togglePRStepVisibility(prCheck.checked);
      prCheck.addEventListener('change',()=>togglePRStepVisibility(prCheck.checked));
    }
  })();

  f.addEventListener('submit',(e)=>{
    e.preventDefault();
    hideError();
    const q=buildQueryParams();
    // 送信直前にも反映
    {
      const prCheck=f.elements.namedItem('with_pr_links');
      if(prCheck instanceof HTMLInputElement){
        togglePRStepVisibility(prCheck.checked);
      }
    }
    if('EventSource' in window){
      startScanWithSSE(q);
    }else{
      startScanWithFetch(q);
    }
  });
  </script>
</body>
</html>
